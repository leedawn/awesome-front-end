# Vue3 官网学习（8.21）

# 开始

1. vue 是一款用于构建用户界面的 JavaScript 框架
2. 两个核心功能
    - **声明式渲染**：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。
    - **响应性**：Vue 会自动跟踪 JavaScript 状态变化并在改变发生时响应式地更新 DOM。
3. Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里
4. 使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 `data`、`methods`
 和 `mounted`。选项所定义的属性都会暴露在函数内部的 `this`上，它会指向当前的组件实例。
5. 通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。
6. 使用 Vue 官方的项目脚手架工具 create-vue 创建项目
7. 不使用构建工具。
    - 使用了全局构建版的 Vue，该版本的所有 API 都暴露在了全局变量 Vue 上。
    - 若想通过原生 ES 模块使用 Vue，使用了一个名为导入映射表 (Import Maps) 的浏览器原生功能。
    - 使用单独的 JavaScript 文件，你需要通过 http:// 协议为你的 HTML 提供服务，而不是 file:// 协议。想启动一个本地的 HTTP 服务器，请先安装 Node.js，然后从命令行在 HTML 文件所在文件夹下运行 npx serve

# 基础
### 创建一个应用
1. 每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例，传入 createApp 的对象实际上是一个组件
2. 应用实例必须在调用了 .mount() 方法后才会渲染出来。.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例
3. 当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板
4. 应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项。确保在挂载应用实例之前完成所有应用配置！
5. 应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。可以用在服务端渲染 HTML

### 模版语法
1. Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码
2. 基本的数据绑定形式是文本插值
3. 想插入 HTML，你需要使用 v-html 指令：
4. 响应式地绑定一个 attribute，应该使用 v-bind 指令。
    - 如果绑定的值是 null 或者 undefined，那么该 attribute 将会从渲染的元素上移除。
    - 真值或一个空字符串 (即 <button disabled="">) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。
    - 不带参数的 v-bind，你可以将包含多个 attribute 的 JavaScript 对象绑定到单个元素上
5. JavaScript 表达式可以用于文本插值和任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中。可以在绑定的表达式中使用一个组件暴露的方法
6. 指令是带有 v- 前缀的特殊 attribute。同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内。修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。

### 响应式基础
1. 使用 reactive() 函数创建一个响应式对象或数组。响应式对象其实是 JavaScript Proxy，其行为表现与一般对象相似。不同之处在于 Vue 能够跟踪对响应式对象属性的访问与更改操作
- 使用 `<script setup>` 来大幅度地简化代码
- 当你更改响应式状态后，DOM 也会自动更新。然而，你得注意 DOM 的更新并不是同步的。
- 状态都是默认深层响应式的
- reactive() 返回的是一个原始对象的 Proxy，它和原始对象是不相等的：
2. 限制
- 仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。
- 因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。
3. 一个 ref() 方法来允许我们创建可以使用任何值类型的响应式 ref。ref() 将传入参数的值包装为一个带 .value 属性的 ref 对象。ref() 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。
- 当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 .value
- 当一个 ref 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包

### 计算属性
1. 使用计算属性来描述依赖响应式状态的复杂逻辑，返回值为一个计算属性 ref
2. 不同之处在于计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算
3. 用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建
4. 不要在计算函数中做异步请求或者更改 DOM。

### class 和 style 的绑定
1. Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。

### 侦听器
1. watch 函数在每次响应式状态发生变化时触发回调函数
2. watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组
3. watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发。
4. 一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调，需要显式地加上 deep 选项，强制转成深层侦听器
5. watchEffect 创建侦听器时，立即执行一遍回调
6. watch 只追踪明确侦听的数据源。watchEffect，则会在副作用发生期间追踪依赖
7. 用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。如果想在侦听器回调中能访问被 Vue 更新之后的DOM，你需要指明 flush: 'post' 选项
8. 侦听器必须用同步语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。要手动停止一个侦听器，请调用 watch 或 watchEffect 返回的函数

### 模版引用
1. 我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用
2. 当在 v-for 中使用模板引用时，对应的 ref 中包含的值是一个数组
3. ref attribute 还可以绑定为一个函数，会在每次组件更新时都被调用
4. 模板引用也可以被用在一个子组件上。这种情况下引用中获得的值的是组件实例
5. 使用了 `<script setup> `的组件是默认私有的，defineExpose 宏显式暴露

### 组件基础

# 应用规模化

1. Vue SFC 是一个框架指定的文件格式，因此必须交由 **[@vue/compiler-sfc](https://github.com/vuejs/core/tree/main/packages/compiler-sfc)**
 编译为标准的 JavaScript 和 CSS，一个编译后的 SFC 是一个标准的 JavaScript(ES) 模块，这也意味着在构建配置正确的前提下，你可以像导入其他 ES 模块一样导入 SFC
2. SFC 中的 `<style>` 标签一般会在开发时注入成原生的 `<style>`标签以支持热更新，而生产环境下它们会被抽取、合并成单独的 CSS 文件。